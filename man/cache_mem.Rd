% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/lib.R
\name{cache_mem}
\alias{cache_mem}
\title{Cache a function or expression in memory.}
\usage{
cache_mem(version = 0, name = NULL, verbose = FALSE, force = FALSE)
}
\arguments{
\item{version}{Change this value to make the cache run its computation again.
Only re-computes one time per version.}

\item{name}{Manually set the name of the cache entry.
Watch out with colliding names if you set this for multiple caches.
The version number will still be appended to the name.}

\item{verbose}{Output information about caching mechanism.}

\item{force}{Force a re-run of the cached code.}
}
\value{
A cached function or the result of a cached expression
}
\description{
The cached function/expression is executed once, the output is saved in RAM.
Subsequent calls will return the saved value, skipping the computation.
}
\details{
\code{cache_mem} tries to detect when code or arguments change,
but it will fail in many situations.
To make sure a computation is re-run,
set \code{force} to TRUE and re-run the code wrapped by \code{cache_mem}.

When \code{cache_mem} caches an expression,
the expression will be evaluated in the frame of \code{cache_mem},
as such it can read/write/modify the local environment.
In-place updates in cached code are discouraged,
because in-place updates combined with caching can get very confusing.
}
\examples{
# Cache a function
test_fn <- cache_mem() \%at\% function(x) {
  message("I was called")
  x + 1
}
test_fn(x = 1) # this will emit a message: "I was called".
test_fn(x = 1) # same output, but silent because the function was not ran again.
test_fn(x = 2) # now it will again emit the message: "I was called"

# Cache an expression
test_expr_1 <- cache_mem() \%at\% {
  message("I was called")
  1 + 1
} # this will emit a message: "I was called"
test_expr_2 <- cache_mem() \%at\% {
  message("I was called")
  1 + 1
} # this will be silent, but same output
test_expr_3 <- cache_mem() \%at\% {
  message("I was called")
  1 + 2
} # code has changed, emits a message again.

# Caching expressions can transparently read/write/modify the outer scope.
var_x <- 1
var_y <- 2
cache_mem() \%at\% {
  var_y <- var_x + var_y # in place update, not recommended
  var_z <- var_y * 2
}
stopifnot(var_y == 3)
stopifnot(var_z == 6)

# Running it again won't do anything, because the computation is cached.
cache_mem() \%at\% {
  var_y <- var_x + var_y # in place update, not recommended
  var_z <- var_y * 2
}
stopifnot(var_y == 3)
stopifnot(var_z == 6)

cache_rm() # clears the cache
}
