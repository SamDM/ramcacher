---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# ramcacher

<!-- badges: start -->
<!-- badges: end -->

ramcacher provides in-memory caching for R functions and expressions. It stores computation results in RAM and automatically invalidates cache entries when code or arguments change. This is useful for speeding up repeated expensive computations during interactive data analysis.

## Installation

You can install the development version of ramcacher from [GitHub](https://github.com/) with any of the following:

``` r
# Using pak
# install.packages("pak")
pak::pkg_install("SamDM/ramcacher")

# Using remotes
# install.packages("remotes")
remotes::install_github("SamDM/ramcacher")

# Using devtools
# install.packages("devtools")
devtools::install_github("SamDM/ramcacher")
```

## Example

### Caching Functions

Wrap a function with `cache_mem()` to cache its results. The first call runs the computation, subsequent calls with the same arguments return the cached result:

```{r example}
library(ramcacher)

# Clear any existing cache
cache_rm()

# Create a cached function using the %at% operator
slow_computation <- cache_mem() %at% function(x) {
  message("Running computation...")
  Sys.sleep(0.1)  # Simulate slow work
  x^2
}

# First call - runs the computation
slow_computation(4)

# Second call with same argument - returns cached result (no message printed)
slow_computation(4)

# Different argument - runs computation again
slow_computation(5)
```

### Caching Expressions

You can also cache arbitrary code blocks. The cache key is based on the code itself:

```{r expressions}
cache_rm()

# Cache an expression
result1 <- cache_mem() %at% {
  message("Computing...")
  sum(1:100)
}

# Same expression returns cached result (no message)
result2 <- cache_mem() %at% {
  message("Computing...")
  sum(1:100)
}

result1 == result2
```

### Cache Management

Inspect and manage cache entries directly:

```{r cache-management}
cache_rm()

# Store some cached values
cache_set("my_data", mtcars[1:3, 1:3])
cache_set("my_result", 42)

# List all cache entries
cache_list()

# Retrieve a cached value
cache_get("my_result")

# Remove specific entries
cache_rm("my_data")
cache_list()

# Clear all cache entries
cache_rm()
cache_list()
```

### Versioning and Forcing Recomputation

Use the `version` parameter to invalidate cache when your logic changes, or `force = TRUE` to always recompute:

```{r versioning}
cache_rm()

# Version 1 of the computation
cached_fn <- cache_mem(version = 1) %at% function(x) {
  message("v1 running")
  x + 1
}
cached_fn(10)

# Bump version to force new computation
cached_fn_v2 <- cache_mem(version = 2) %at% function(x) {
  message("v2 running")
  x + 1
}
cached_fn_v2(10)

# Or use force = TRUE to always recompute
forced_fn <- cache_mem(force = TRUE) %at% function(x) {
  message("Forced run")
  x + 1
}
forced_fn(10)
```

### Debugging with Verbose Mode

Enable verbose output to see cache hits and misses:

```{r verbose}
cache_rm()

cached_fn <- cache_mem(verbose = TRUE) %at% function(x) x * 2

cached_fn(5)  # Cache miss
cached_fn(5)  # Cache hit
```

## Citation

If you use ramcacher in your research, please cite it as:

### BibTeX

```bibtex
@software{demeyer2024ramcacher,
  author = {De Meyer, Sam},
  title = {ramcacher: In-Memory Caching for Functions and Expressions in R},
  year = {2024},
  url = {https://github.com/SamDM/ramcacher},
  version = {0.1.0}
}
```

### Hayagriva (Typst)

```yaml
ramcacher:
  type: software
  author: De Meyer, Sam
  title: "ramcacher: In-Memory Caching for Functions and Expressions in R"
  date: 2024
  url: https://github.com/SamDM/ramcacher
  version: "0.1.0"
```